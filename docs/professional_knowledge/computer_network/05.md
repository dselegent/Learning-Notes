

# 05 【计算机网络-运输层】

## 1.运输层概述

### 1.1 概念

**进程之间的通信**

![image-20240618101829778](https://i0.hdslb.com/bfs/article/c3e0dc7e84683c20677b3b4689d2e6ce3493119651743993.png)

* 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，**它属于面向通信部分的最高层，同时也是用户功能中的最低层**。
* 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，**只有位于网络边缘部分的主机的协议栈才有运输层**，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。 

![image-20240618102252050](https://i0.hdslb.com/bfs/article/30a56757c3504a8db1e8b5bec1c313323493119651743993.png)

**进程之间通信流程**

![image-20240618102259386](https://i0.hdslb.com/bfs/article/b2f841cb1288302a9a5e25bf31e1898b3493119651743993.png)

“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的

> 进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信
>
> 在运输层使用不同的端口，来对应不同的应用进程
>
> 然后通过网络层及其下层来传输应用层报文
>
> 接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程
>
> 这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符

![image-20240618102309020](https://i0.hdslb.com/bfs/article/e88c53330c0f113fa3097e72485489913493119651743993.png)

### 1.2 总结

![image-20240618102313962](https://i0.hdslb.com/bfs/article/f0d39f729c68f5550a46ecf0605b73333493119651743993.png)

![image-20240618102319166](https://i0.hdslb.com/bfs/article/82055d6c51a36cd587ea85bd2a9e5bef3493119651743993.png)

## 2.运输层端口号、复用与分用的概念

### 2.1 为什么用端口号

![image-20240618102324925](https://i0.hdslb.com/bfs/article/276cbd0233bca45698d93db10f8e57cd3493119651743993.png)

### 2.2 发送方的复用和接收方的分用

![image-20240618102330609](https://i0.hdslb.com/bfs/article/e4e97cfec216982ad719a2f204068c8e3493119651743993.png)

> **多个进程（这里一个端口表示一个进程）** 利用一个运输层协议（或者称为运输层接口）**发送**数据称为 **复用**
>
> **多个进程（这里一个端口表示一个进程）** 利用一个运输层协议（或者称为运输层接口）**接收**时叫做  **分用**。

### 2.3 TCP/IP体系的应用层常用协议所使用的运输层熟知端口号

![image-20240618102337880](https://i0.hdslb.com/bfs/article/89134f6fb06b1a1672bd3274e0a29bb73493119651743993.png)

### 2.4 运输层传输流程

举例

![image-20240618102343069](https://i0.hdslb.com/bfs/article/cb6788d9697eefdebc6935ad14e0065c3493119651743993.png)

> 在浏览器输入域名，回车浏览
>
> 然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文
>
> DNS查询请求报文需要使用运输层的UDP协议
>
> 首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程
>
> 首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号

![image-20240618102349485](https://i0.hdslb.com/bfs/article/4de165cecba5aa27b0e5a548916ef8033493119651743993.png)

> 之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器

![image-20240618102357114](https://i0.hdslb.com/bfs/article/a1b08021974f3ad5605b0ba86e2024393493119651743993.png)

> DNS服务器收到该IP数据报后，从中解封出UDP用户数据报
>
> UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程
>
> DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址
>
> 之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报
>
> 其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号

![image-20240618102405439](https://i0.hdslb.com/bfs/article/fcf48d7ae2cadc3cb33e329e3722e4d33493119651743993.png)

> 将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC

![image-20240618102410597](https://i0.hdslb.com/bfs/article/4506e17482249b9b99788eb9939901483493119651743993.png)

> 用户PC收到该数据报后，从中解封出UDP用户数据报
>
> UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程
>
> DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址

现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）

![image-20240618102418400](https://i0.hdslb.com/bfs/article/7f29e1fcf80efea131ac9c22c840b45f3493119651743993.png)

![image-20240618102429624](https://i0.hdslb.com/bfs/article/2410a92bb446c0bfd76ec59f1ce50c733493119651743993.png)

![image-20240618102437020](https://i0.hdslb.com/bfs/article/529bb5bd438d93c1fb133abd72ca1d163493119651743993.png)

![image-20240618102453184](https://i0.hdslb.com/bfs/article/1239d3bf381aee8194cc8a65b91db3443493119651743993.png)

![image-20240618102508759](https://i0.hdslb.com/bfs/article/576ddcc5ab4c8e6c2f6da8ff646a1f383493119651743993.png)

## 3.UDP和TCP的对比

### 3.1 概念

* **UDP** 和 **TCP** 是TCP/IP体系结构**运输层**中的两个重要协议
* 当运输层采用面向连接的 **TCP** 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条**全双工的可靠信道**。
* 当运输层采用无连接的 **UDP** 协议时，这种逻辑通信信道是一条**不可靠信道**。 

可靠信道与不可靠信道

![image-20240618102513872](https://i0.hdslb.com/bfs/article/44fdbb3c23e9722eaa0d659d22ec09a23493119651743993.png)

* 两个对等运输实体在通信时传送的数据单位叫作**运输协议数据单元** TPDU (Transport Protocol Data Unit)。
* TCP 传送的数据单位协议是 **TCP 报文段**(segment)。

* UDP 传送的数据单位协议是 **UDP 报文**或**用户数据报**。

![image-20240618102523451](https://i0.hdslb.com/bfs/article/5116e0cf677cf58ee236994c19f87d0f3493119651743993.png)

UDP的通信是无连接的，不需要套接字（Socket）

TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接

### 3.2 用户数据报协议UDP（User Datagram Protocol）

可以发送广播

![image-20240618102529815](https://i0.hdslb.com/bfs/article/4ee93029a0fec95673ba67e1037968303493119651743993.png)

可以向某个多播组发送多播

![image-20240618102538525](https://i0.hdslb.com/bfs/article/423ec3db0f60120074a96ec9fe61541e3493119651743993.png)

还可以发送单播

![image-20240618102544251](https://i0.hdslb.com/bfs/article/3172a3b95a7a2f10fa2966c8f6d81b383493119651743993.png)

> UDP 支持单播、多播以及广播
>
> 换句话说，UDP支持一对一，一对多，以及一对全的通信

运输过程

![image-20240618102550174](https://i0.hdslb.com/bfs/article/ecb39ae00b21517fb4938d267384f03a3493119651743993.png)

> UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界
>
> 换句话说，UDP是面向应用报文的

UDP向上层提供无连接不可靠传输服务

![image-20240618102557480](https://i0.hdslb.com/bfs/article/9df3495ab7cff1d091b96a2fca5af8af3493119651743993.png)

UDP结构

![image-20240618102603173](https://i0.hdslb.com/bfs/article/f7e47f658418ac19dbd31b2bc94c756c3493119651743993.png)

### 3.3 传输控制协议TCP（Transmission Control Protocol）

使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接

![image-20240618102612746](https://i0.hdslb.com/bfs/article/627cbe4956173d9d3864db6abff706fa3493119651743993.png)

TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信

![image-20240618102621957](https://i0.hdslb.com/bfs/article/a40e4b6d372a3a746e508e1b3dfe09843493119651743993.png)

> 很显然，TCP仅支持单播，也就是一对一的通信

运输过程

![image-20240618102638027](https://i0.hdslb.com/bfs/article/296e957ed82c38796f0fdafef4114ff83493119651743993.png)

> 发送方
>
> * TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义
>
> * 并将他们编号，并存储在自己发送缓存中
>
> * TCP会根据发送策略，提取一定量的字节构建TCP报文并发送
>
> 接收方
>
> * 一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程
> * TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）
> * 接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据
>
> TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础
>
> 本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收

TCP向上层提供面向连接的可靠传输服务

![image-20240618102646806](https://i0.hdslb.com/bfs/article/236362fb3f6d618f31adda2ac21d81683493119651743993.png)

TCP结构

![image-20240618102653145](https://i0.hdslb.com/bfs/article/27498568cce4d4c4eec1ab764142d1fb3493119651743993.png)

### 3.4 总结

![image-20240618102700225](https://i0.hdslb.com/bfs/article/bd5d38d070f5b66c6f7d0e68e8cc92d13493119651743993.png)

## 4.TCP的流量控制

### 4.1 概念

![image-20240618102708937](https://i0.hdslb.com/bfs/article/ee533d7565da67380364d51bc80216593493119651743993.png)

举例

[具体流程的视频](https://www.bilibili.com/video/BV1c4411d7jb?p=60)

![image-20240618102716188](https://i0.hdslb.com/bfs/article/749922f17e2fa3773d5ebf27a02a882b3493119651743993.png)

上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认

![image-20240618102722500](https://i0.hdslb.com/bfs/article/b44e62e7393386de8d9255ecc7196e043493119651743993.png)

上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认

![image-20240618102748989](https://i0.hdslb.com/bfs/article/0848fa470d68b48f2d56ad583c0793b23493119651743993.png)

![image-20240618102814545](https://i0.hdslb.com/bfs/article/716aa27d821f72d3e24084da6e8271223493119651743993.png)

上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认



![image-20240618103732399](https://i0.hdslb.com/bfs/article/e356b4ee195d75a1c3d9179f3b39b74e3493119651743993.png)

![image-20240618103738301](https://i0.hdslb.com/bfs/article/02911970f0ce9940e56fbe18e7b79c353493119651743993.png)

> 上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面
>
> 因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传

### 4.2 总结

![image-20240618102909642](https://i0.hdslb.com/bfs/article/0660005ecfd010b1096398e2e24029813493119651743993.png)

## 5.TCP的拥塞控制

### 5.1 概念

![image-20240618102921109](https://i0.hdslb.com/bfs/article/fbedf0e3d0e1207316ef82f34fbc88a33493119651743993.png)

**网络拥塞往往是由许多因素引起的。例如：**

1. 点缓存的容量太小；
2. 链路的容量不足；
3. 处理机处理的速率太慢；
4. 拥塞本身会进一步加剧拥塞；

**拥塞控制的一般原理**

* 拥塞控制的前提：网络能够承受现有的网络负荷。
* 实践证明，拥塞控制是很难设计的，因为它是一个**动态问题**。
* 分组的丢失是网络发生拥塞的**征兆**而不是原因。
* 在许多情况下，甚至正是**拥塞控制本身**成为引起网络性能恶化、甚至发生死锁的原因。

**开环控制和闭环控制**

![image-20240618102930283](https://i0.hdslb.com/bfs/article/1a31fd078653a8dad9db4846340643f33493119651743993.png)

**监测网络的拥塞**

主要指标有：

1. 由于缺少缓存空间而被丢弃的分组的百分数；
2. 平均队列长度；
3. 超时重传的分组数；
4. 平均分组时延；
5. 分组时延的标准差，等等。

上述这些指标的上升都标志着拥塞的增长。



### 5.2 拥塞控制的算法

![image-20240618102940804](https://i0.hdslb.com/bfs/article/df6afe47393580954420bf20bd04592b3493119651743993.png)

![image-20240618102947532](https://i0.hdslb.com/bfs/article/58e17471448a7dd4a9d1d267b621c7ed3493119651743993.png)

> 真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)



下图的实例横纵坐标的意思

传输轮次：

* 发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段
* 一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值
* 使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认

拥塞窗口：

* 它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化



#### 慢开始和拥塞避免

##### 慢开始（slow-start）

* 目的：用来确定网络的负载能力或拥塞程度。
* 算法的思路：由小到大逐渐增大拥塞窗口数值。
* 两个变量：
  * **拥塞窗口（cwnd）**：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。
    * 1 至 2 个最大报文段 （旧标准）
    * 2 至 4 个最大报文段 （RFC 5681）
  * **慢开始门限（ssthresh）**：防止拥塞窗口增长过大引起网络拥塞。

![image-20240618102955641](https://i0.hdslb.com/bfs/article/1805397cb9b96370a5c3d95a291a408b3493119651743993.png)

![image-20240618103000611](https://i0.hdslb.com/bfs/article/782ef370b39d02011d75bbdd0f5924b23493119651743993.png)

> 图中swnd是发送窗口
>
> 每经过一个传输轮次，拥塞窗口就加倍
>
> 窗口大小按**指数增加**，2的n-1次方



##### 拥塞避免（congestion avoidance）

* 思路：让拥塞窗口 cwnd **缓慢地增大**，避免出现拥塞。
* 每经过一个传输轮次，拥塞窗口 **cwnd = cwnd + 1**。
* 使拥塞窗口 cwnd 按线性规律缓慢增长。
* 在拥塞避免阶段，具有 “**加法增大**” (Additive Increase) 的特点。

![image-20240618103007291](https://i0.hdslb.com/bfs/article/19b2465ca25678e9c9c0aed3d3f237fb3493119651743993.png)

如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传

![image-20240618103013446](https://i0.hdslb.com/bfs/article/22c277eaba8da6ad8b46ac2eecc5e27e3493119651743993.png)

这个时候又回到了慢开始

![image-20240618103021831](https://i0.hdslb.com/bfs/article/2035c4dac2c5fdac589df1da1c218fc43493119651743993.png)

![image-20240618103028747](https://i0.hdslb.com/bfs/article/0a90a1e1d6fa06c83318ba636bf4e1d93493119651743993.png)



##### 两个算法完整示意图

![image-20240618103041144](https://i0.hdslb.com/bfs/article/8a104c2c0924495c42f6bafa6d5dee093493119651743993.png)



#### 快重传和快恢复

![image-20240618103046519](https://i0.hdslb.com/bfs/article/9d0509c15083389e60a3bd39a821aa7b3493119651743993.png)



##### 快重传（fast retrasmit）

![image-20240618103716805](https://i0.hdslb.com/bfs/article/865a6173247fcf649012682dfa7cc7823493119651743993.png)



##### 快恢复（fast recovery）

![image-20240618103104669](https://i0.hdslb.com/bfs/article/91219a0042415328e5d23851df358d003493119651743993.png)



##### 改进后的整体算法的示意图

![image-20240618103111818](https://i0.hdslb.com/bfs/article/7870b19fc828b5d2cd795adcd57e05b73493119651743993.png)



------



## 6.TCP超时重传时间的选择

![image-20240618103125076](https://i0.hdslb.com/bfs/article/514357751468835c9221b317b93d92f83493119651743993.png)

> 如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大

![image-20240618103130559](https://i0.hdslb.com/bfs/article/8560f49e4525bdf15a8926d493b7536b3493119651743993.png)

> 如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率

![image-20240618103136846](https://i0.hdslb.com/bfs/article/cd700cd7ddc0d42de8d5f5682c1733273493119651743993.png)

![image-20240618103142153](https://i0.hdslb.com/bfs/article/2082c62ebb40344f744c0b1573e606493493119651743993.png)



**RFC6298建议使用下式计算超时重传时间RTO**

![image-20240618103213066](https://i0.hdslb.com/bfs/article/831bdd9d86a0657e4f352816c800d6c63493119651743993.png)



**往返时间RTT的测量比较复杂**

![image-20240618103218582](https://i0.hdslb.com/bfs/article/847f774d1ff50fa1d79c28de160a446b3493119651743993.png)

![image-20240618103223809](https://i0.hdslb.com/bfs/article/51fd7a4320b9708fa92b596b4b6691c13493119651743993.png)



**TCP超时重传的计算**

举例

![image-20240618103231333](https://i0.hdslb.com/bfs/article/25d6df7902305c5f9a00328372bb04f93493119651743993.png)



**总结**

![image-20240618103236349](https://i0.hdslb.com/bfs/article/a3727b6468c390409cda58b1217031af3493119651743993.png)



------



## 7.TCP可靠传输的实现

[本集具体讲解](https://www.bilibili.com/video/BV1c4411d7jb?p=63)

![image-20240618103245845](https://i0.hdslb.com/bfs/article/3856f72478924a2429021df62ef0821f3493119651743993.png)

![image-20240618103250472](https://i0.hdslb.com/bfs/article/ee0fb3094d2229fbeb0c2eaa7e8c79f73493119651743993.png)



![image-20240618103255915](https://i0.hdslb.com/bfs/article/20c596db0f2b392d444eb8006b66476d3493119651743993.png)

## 8.TCP的运输连接管理

### 8.1 概念

![image-20240618103301043](https://i0.hdslb.com/bfs/article/7d61a593d0c807d97ce6543662677fc73493119651743993.png)

### 8.2 TCP的连接建立

* TCP 建立连接的过程叫做**握手**。
* 握手需要在客户和服务器之间交换三个 TCP 报文段。称之为**三报文握手**。
* 采用**三报文握手**主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。

#### TCP的连接建立要解决以下三个问题

![image-20240618103306737](https://i0.hdslb.com/bfs/article/0835fd0c501ccd1a01dbd7ce39a0a8e03493119651743993.png)

#### TCP使用“三报文握手”建立连接

* TCP 连接的建立**采用客户服务器方式**。
* 主动发起连接建立的应用进程叫做**TCP客户** (client)。
* 被动等待连接建立的应用进程叫做**TCP服务器** (server)。

“握手”需要在TCP客户端和服务器之间交换三个TCP报文段

过程

![image-20240618103311824](https://i0.hdslb.com/bfs/article/7c9ca919b3eb29d5034c05545822983b3493119651743993.png)

> 最初两端的TCP进程都处于关闭状态

![image-20240618103318598](https://i0.hdslb.com/bfs/article/9bb7673d3035d85eaa62786da5b0ba503493119651743993.png)

> 一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等
>
> 之后，就准备接受TCP客户端进程的连接请求
>
> 此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求

TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为**被动打开**连接

![image-20240618103326082](https://i0.hdslb.com/bfs/article/6ab4d2cc9274bd042721fee33ae1cd1f3493119651743993.png)

> TCP客户进程也是首先创建传输控制块

由于TCP连接建立是由TCP客户端主动发起的，因此称为**主动打开**连接

![image-20240618103331833](https://i0.hdslb.com/bfs/article/45c3d90ffc0d65657ed8688ea61360eb3493119651743993.png)

> 然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态
>
> TCP连接请求报文段首部中
>
> * 同步位SYN被设置为1，表明这是一个TCP连接请求报文段
> * 序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号
>
> 请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号

![image-20240618103336104](https://i0.hdslb.com/bfs/article/7aa4a96c00ea4a7f4d6c78f392b0b9663493119651743993.png)

> TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态
>
> TCP连接请求确认报文段首部中
>
> * 同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段
> * 序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，
> * 确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认
>
> 请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号

![image-20240618103341914](https://i0.hdslb.com/bfs/article/216c5e3f909ca19d4968ed2c7e41ccf33493119651743993.png)

> TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已建立状态
>
> 普通的TCP确认报文段首部中
>
> * 确认位ACK被设置为1，表明这是一个普通的TCP确认报文段
> * 序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1
> * 确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认
>
> 请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号

![image-20240618103347599](https://i0.hdslb.com/bfs/article/9a1703b56fe9b83be48fff6de1bfb4533493119651743993.png)

> TCP服务器进程收到该确认报文段后也进入连接已建立状态
>
> 现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输

为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？

下图实例是“两报文握手”

![image-20240618103354004](https://i0.hdslb.com/bfs/article/209d8c55bdd48012ce14ede4895e324f3493119651743993.png)

> 为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有> 丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个> 早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同> 意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因> 此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。
>
> 所以并不**多余**，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误

#### 总结

![image-20240618103402137](https://i0.hdslb.com/bfs/article/bdb3f5fd6d0cc6a1e90dbf30204855f23493119651743993.png)

### TCP的连接释放

* TCP 连接释放过程比较复杂。
* 数据传输结束后，通信的双方都可释放连接。
* TCP 连接释放过程是**四报文握手**。

#### TCP通过“四报文挥手”来释放连接

* TCP 连接的建立**采用客户服务器方式**。
* 主动发起连接建立的应用进程叫做**TCP客户** (client)。
* 被动等待连接建立的应用进程叫做**TCP服务器** (server)。
* **任何一方都可以在数据传送结束后发出连接释放的通知**

过程

![image-20240618103408965](https://i0.hdslb.com/bfs/article/9b210db53f8c5a4975c8172c07a8b52d3493119651743993.png)

> 现在TCP客户进程和TCP服务器进程都处于连接已建立状态
>
> TCP客户进程的应用进程通知其主动关闭TCP连接
>
> TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态
>
> TCP连接释放报文段首部中
>
> * 终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认
> * 序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1
> * 确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1
>
> 请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号

![image-20240618103414713](https://i0.hdslb.com/bfs/article/f8f4bda5b77ba63730e5ee6838d531d63493119651743993.png)

> TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态
>
> 普通的TCP确认报文段首部中
>
> * 确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段
> * 序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配
> * 确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认

![image-20240618103420776](https://i0.hdslb.com/bfs/article/3b20791774b1c269e29ebab1768b96933493119651743993.png)

> TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接
>
> 此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了
>
> 这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了
>
> 但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭

![image-20240618103427261](https://i0.hdslb.com/bfs/article/7c29103b847eeb934b0b827dfe7a256a3493119651743993.png)

> TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段
>
> 若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接
>
> 由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接

![image-20240618103435945](https://i0.hdslb.com/bfs/article/6c48ac6a7318c0252b694d3a382af3163493119651743993.png)

> TCP服务器进程发送TCP连接释放报文段并进入最后确认状态
>
> 该报文段首部中
>
> * 终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认
> * 序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送
> * 确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认

![image-20240618103441540](https://i0.hdslb.com/bfs/article/39d70dcc779b567a6c0e0080933be5b83493119651743993.png)

> TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态
>
> 该报文段首部中
>
> * 确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段
> * 序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号
> * 确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认
>
> TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态

TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？

![image-20240618103512874](https://i0.hdslb.com/bfs/article/d34c95a44905c1506506a12aa4dad05e3493119651743993.png)

> 因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态
>
> 另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段

#### TCP保活计时器的作用

TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障

TCP服务器进程以后就不能再收到TCP客户进程发来的数据

因此，应当有措施使TCP服务器进程不要再白白等待下去

![image-20240618103459799](https://i0.hdslb.com/bfs/article/dfc12a69f1d906acaf53f33790270db63493119651743993.png)

## 9.TCP报文段的首部格式

![image-20240618103520586](https://i0.hdslb.com/bfs/article/7f59864f2af76860f0a035e2b24191cb3493119651743993.png)

### 9.1 各字段的作用

源端口和目的端口

![image-20240618103526110](https://i0.hdslb.com/bfs/article/e2a00702b3c7c4c3a7b326f8ad90aa2b3493119651743993.png)

序号、确认号和确认标志位

![image-20240618103551099](https://i0.hdslb.com/bfs/article/199293684861648c98daf031660edc4b3493119651743993.png)

数据偏移、保留、窗口和校验和

![image-20240618103540678](https://i0.hdslb.com/bfs/article/6ba6a9fee62bbbad5dbda0de9d7572513493119651743993.png)

同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针

![image-20240618103601953](https://i0.hdslb.com/bfs/article/101c64c786b2feaa92f77a0d4334d0003493119651743993.png)

选项和填充

![image-20240618103619406](https://i0.hdslb.com/bfs/article/bd0ee7c7e015e9c08022f4c94d762d733493119651743993.png)



